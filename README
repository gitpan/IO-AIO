NAME
    IO::AIO - Asynchronous Input/Output

SYNOPSIS
     use IO::AIO;

     aio_open "/etc/passwd", O_RDONLY, 0, sub {
        my ($fh) = @_;
        ...
     };

     aio_unlink "/tmp/file", sub { };

     aio_read $fh, 30000, 1024, $buffer, 0, sub {
        $_[0] > 0 or die "read error: $!";
     };

     # AnyEvent
     open my $fh, "<&=" . IO::AIO::poll_fileno or die "$!";
     my $w = AnyEvent->io (fh => $fh, poll => 'r', cb => sub { IO::AIO::poll_cb });

     # Event
     Event->io (fd => IO::AIO::poll_fileno,
                poll => 'r',
                cb => \&IO::AIO::poll_cb);

     # Glib/Gtk2
     add_watch Glib::IO IO::AIO::poll_fileno,
               in => sub { IO::AIO::poll_cb; 1 };

     # Tk
     Tk::Event::IO->fileevent (IO::AIO::poll_fileno, "",
                               readable => \&IO::AIO::poll_cb);

     # Danga::Socket
     Danga::Socket->AddOtherFds (IO::AIO::poll_fileno =>
                                 \&IO::AIO::poll_cb);

DESCRIPTION
    This module implements asynchronous I/O using whatever means your
    operating system supports.

    Currently, a number of threads are started that execute your read/writes
    and signal their completion. You don't need thread support in your libc
    or perl, and the threads created by this module will not be visible to
    the pthreads library. In the future, this module might make use of the
    native aio functions available on many operating systems. However, they
    are often not well-supported (Linux doesn't allow them on normal files
    currently, for example), and they would only support aio_read and
    aio_write, so the remaining functionality would have to be implemented
    using threads anyway.

    Although the module will work with in the presence of other threads, it
    is currently not reentrant, so use appropriate locking yourself, always
    call "poll_cb" from within the same thread, or never call "poll_cb" (or
    other "aio_" functions) recursively.

FUNCTIONS
  AIO FUNCTIONS
    All the "aio_*" calls are more or less thin wrappers around the syscall
    with the same name (sans "aio_"). The arguments are similar or
    identical, and they all accept an additional (and optional) $callback
    argument which must be a code reference. This code reference will get
    called with the syscall return code (e.g. most syscalls return -1 on
    error, unlike perl, which usually delivers "false") as it's sole
    argument when the given syscall has been executed asynchronously.

    All functions expecting a filehandle keep a copy of the filehandle
    internally until the request has finished.

    The pathnames you pass to these routines *must* be absolute and encoded
    in byte form. The reason for the former is that at the time the request
    is being executed, the current working directory could have changed.
    Alternatively, you can make sure that you never change the current
    working directory.

    To encode pathnames to byte form, either make sure you either: a) always
    pass in filenames you got from outside (command line, readdir etc.), b)
    are ASCII or ISO 8859-1, c) use the Encode module and encode your
    pathnames to the locale (or other) encoding in effect in the user
    environment, d) use Glib::filename_from_unicode on unicode filenames or
    e) use something else.

    aio_open $pathname, $flags, $mode, $callback->($fh)
        Asynchronously open or create a file and call the callback with a
        newly created filehandle for the file.

        The pathname passed to "aio_open" must be absolute. See API NOTES,
        above, for an explanation.

        The $flags argument is a bitmask. See the "Fcntl" module for a list.
        They are the same as used by "sysopen".

        Likewise, $mode specifies the mode of the newly created file, if it
        didn't exist and "O_CREAT" has been given, just like perl's
        "sysopen", except that it is mandatory (i.e. use 0 if you don't
        create new files, and 0666 or 0777 if you do).

        Example:

           aio_open "/etc/passwd", O_RDONLY, 0, sub {
              if ($_[0]) {
                 print "open successful, fh is $_[0]\n";
                 ...
              } else {
                 die "open failed: $!\n";
              }
           };

    aio_close $fh, $callback->($status)
        Asynchronously close a file and call the callback with the result
        code. *WARNING:* although accepted, you should not pass in a perl
        filehandle here, as perl will likely close the file descriptor
        another time when the filehandle is destroyed. Normally, you can
        safely call perls "close" or just let filehandles go out of scope.

        This is supposed to be a bug in the API, so that might change. It's
        therefore best to avoid this function.

    aio_read $fh,$offset,$length, $data,$dataoffset, $callback->($retval)
    aio_write $fh,$offset,$length, $data,$dataoffset, $callback->($retval)
        Reads or writes "length" bytes from the specified "fh" and "offset"
        into the scalar given by "data" and offset "dataoffset" and calls
        the callback without the actual number of bytes read (or -1 on
        error, just like the syscall).

        The $data scalar *MUST NOT* be modified in any way while the request
        is outstanding. Modifying it can result in segfaults or WW3 (if the
        necessary/optional hardware is installed).

        Example: Read 15 bytes at offset 7 into scalar $buffer, starting at
        offset 0 within the scalar:

           aio_read $fh, 7, 15, $buffer, 0, sub {
              $_[0] > 0 or die "read error: $!";
              print "read $_[0] bytes: <$buffer>\n";
           };

    aio_sendfile $out_fh, $in_fh, $in_offset, $length, $callback->($retval)
        Tries to copy $length bytes from $in_fh to $out_fh. It starts
        reading at byte offset $in_offset, and starts writing at the current
        file offset of $out_fh. Because of that, it is not safe to issue
        more than one "aio_sendfile" per $out_fh, as they will interfere
        with each other.

        This call tries to make use of a native "sendfile" syscall to
        provide zero-copy operation. For this to work, $out_fh should refer
        to a socket, and $in_fh should refer to mmap'able file.

        If the native sendfile call fails or is not implemented, it will be
        emulated, so you can call "aio_sendfile" on any type of filehandle
        regardless of the limitations of the operating system.

        Please note, however, that "aio_sendfile" can read more bytes from
        $in_fh than are written, and there is no way to find out how many
        bytes have been read from "aio_sendfile" alone, as "aio_sendfile"
        only provides the number of bytes written to $out_fh. Only if the
        result value equals $length one can assume that $length bytes have
        been read.

    aio_readahead $fh,$offset,$length, $callback->($retval)
        "aio_readahead" populates the page cache with data from a file so
        that subsequent reads from that file will not block on disk I/O. The
        $offset argument specifies the starting point from which data is to
        be read and $length specifies the number of bytes to be read. I/O is
        performed in whole pages, so that offset is effectively rounded down
        to a page boundary and bytes are read up to the next page boundary
        greater than or equal to (off-set+length). "aio_readahead" does not
        read beyond the end of the file. The current file offset of the file
        is left unchanged.

        If that syscall doesn't exist (likely if your OS isn't Linux) it
        will be emulated by simply reading the data, which would have a
        similar effect.

    aio_stat $fh_or_path, $callback->($status)
    aio_lstat $fh, $callback->($status)
        Works like perl's "stat" or "lstat" in void context. The callback
        will be called after the stat and the results will be available
        using "stat _" or "-s _" etc...

        The pathname passed to "aio_stat" must be absolute. See API NOTES,
        above, for an explanation.

        Currently, the stats are always 64-bit-stats, i.e. instead of
        returning an error when stat'ing a large file, the results will be
        silently truncated unless perl itself is compiled with large file
        support.

        Example: Print the length of /etc/passwd:

           aio_stat "/etc/passwd", sub {
              $_[0] and die "stat failed: $!";
              print "size is ", -s _, "\n";
           };

    aio_unlink $pathname, $callback->($status)
        Asynchronously unlink (delete) a file and call the callback with the
        result code.

    aio_rmdir $pathname, $callback->($status)
        Asynchronously rmdir (delete) a directory and call the callback with
        the result code.

    aio_readdir $pathname, $callback->($entries)
        Unlike the POSIX call of the same name, "aio_readdir" reads an
        entire directory (i.e. opendir + readdir + closedir). The entries
        will not be sorted, and will NOT include the "." and ".." entries.

        The callback a single argument which is either "undef" or an
        array-ref with the filenames.

    aio_scandir $path, $maxreq, $callback->($dirs, $nondirs)
        Scans a directory (similar to "aio_readdir") and tries to separate
        the entries of directory $path into two sets of names, ones you can
        recurse into (directories), and ones you cannot recurse into
        (everything else).

        "aio_scandir" is a composite request that consists of many
        aio-primitives. $maxreq specifies the maximum number of outstanding
        aio requests that this function generates. If it is "<= 0", then a
        suitable default will be chosen (currently 8).

        On error, the callback is called without arguments, otherwise it
        receives two array-refs with path-relative entry names.

        Example:

           aio_scandir $dir, 0, sub {
              my ($dirs, $nondirs) = @_;
              print "real directories: @$dirs\n";
              print "everything else: @$nondirs\n";
           };

        Implementation notes.

        The "aio_readdir" cannot be avoided, but "stat()"'ing every entry
        can.

        After reading the directory, the modification time, size etc. of the
        directory before and after the readdir is checked, and if they
        match, the link count will be used to decide how many entries are
        directories (if >= 2). Otherwise, no knowledge of the number of
        subdirectories will be assumed.

        Then entires will be sorted into likely directories (everything
        without a non-initial dot) and likely non-directories (everything
        else). Then every entry + "/." will be "stat"'ed, likely directories
        first. This is often faster because filesystems might detect the
        type of the entry without reading the inode data (e.g. ext2fs
        filetype feature). If that succeeds, it assumes that the entry is a
        directory or a symlink to directory (which will be checked
        seperately).

        If the known number of directories has been reached, the rest of the
        entries is assumed to be non-directories.

    aio_fsync $fh, $callback->($status)
        Asynchronously call fsync on the given filehandle and call the
        callback with the fsync result code.

    aio_fdatasync $fh, $callback->($status)
        Asynchronously call fdatasync on the given filehandle and call the
        callback with the fdatasync result code.

        If this call isn't available because your OS lacks it or it couldn't
        be detected, it will be emulated by calling "fsync" instead.

  SUPPORT FUNCTIONS
    $fileno = IO::AIO::poll_fileno
        Return the *request result pipe file descriptor*. This filehandle
        must be polled for reading by some mechanism outside this module
        (e.g. Event or select, see below or the SYNOPSIS). If the pipe
        becomes readable you have to call "poll_cb" to check the results.

        See "poll_cb" for an example.

    IO::AIO::poll_cb
        Process all outstanding events on the result pipe. You have to call
        this regularly. Returns the number of events processed. Returns
        immediately when no events are outstanding.

        Example: Install an Event watcher that automatically calls
        IO::AIO::poll_cb with high priority:

           Event->io (fd => IO::AIO::poll_fileno,
                      poll => 'r', async => 1,
                      cb => \&IO::AIO::poll_cb);

    IO::AIO::poll_wait
        Wait till the result filehandle becomes ready for reading (simply
        does a "select" on the filehandle. This is useful if you want to
        synchronously wait for some requests to finish).

        See "nreqs" for an example.

    IO::AIO::nreqs
        Returns the number of requests currently outstanding (i.e. for which
        their callback has not been invoked yet).

        Example: wait till there are no outstanding requests anymore:

           IO::AIO::poll_wait, IO::AIO::poll_cb
              while IO::AIO::nreqs;

    IO::AIO::flush
        Wait till all outstanding AIO requests have been handled.

        Strictly equivalent to:

           IO::AIO::poll_wait, IO::AIO::poll_cb
              while IO::AIO::nreqs;

    IO::AIO::poll
        Waits until some requests have been handled.

        Strictly equivalent to:

           IO::AIO::poll_wait, IO::AIO::poll_cb
              if IO::AIO::nreqs;

    IO::AIO::min_parallel $nthreads
        Set the minimum number of AIO threads to $nthreads. The current
        default is 4, which means four asynchronous operations can be done
        at one time (the number of outstanding operations, however, is
        unlimited).

        IO::AIO starts threads only on demand, when an AIO request is queued
        and no free thread exists.

        It is recommended to keep the number of threads low, as some Linux
        kernel versions will scale negatively with the number of threads
        (higher parallelity => MUCH higher latency). With current Linux 2.6
        versions, 4-32 threads should be fine.

        Under most circumstances you don't need to call this function, as
        the module selects a default that is suitable for low to moderate
        load.

    IO::AIO::max_parallel $nthreads
        Sets the maximum number of AIO threads to $nthreads. If more than
        the specified number of threads are currently running, this function
        kills them. This function blocks until the limit is reached.

        While $nthreads are zero, aio requests get queued but not executed
        until the number of threads has been increased again.

        This module automatically runs "max_parallel 0" at program end, to
        ensure that all threads are killed and that there are no outstanding
        requests.

        Under normal circumstances you don't need to call this function.

    $oldnreqs = IO::AIO::max_outstanding $nreqs
        Sets the maximum number of outstanding requests to $nreqs. If you
        try to queue up more than this number of requests, the caller will
        block until some requests have been handled.

        The default is very large, so normally there is no practical limit.
        If you queue up many requests in a loop it often improves speed if
        you set this to a relatively low number, such as 100.

        Under normal circumstances you don't need to call this function.

  FORK BEHAVIOUR
    Before the fork, IO::AIO enters a quiescent state where no requests can
    be added in other threads and no results will be processed. After the
    fork the parent simply leaves the quiescent state and continues
    request/result processing, while the child clears the request/result
    queue (so the requests started before the fork will only be handled in
    the parent). Threats will be started on demand until the limit ste in
    the parent process has been reached again.

SEE ALSO
    Coro, Linux::AIO.

AUTHOR
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/

